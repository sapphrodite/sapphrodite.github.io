<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="/theme.css">
    <title> Game Design with ECS  - Caroline's Development Blog </title>
</head>
<body>
    <header id = "site-header">
        <span> Caroline's Development Blog </span>
        <nav id = "navmenu">
            <ul>
                <li> <a class = "modlink" href="/"> Main page </a>
                <li> <a class = "modlink" href=/archive/> Archives </a>
                <li> <a class = "modlink" href="https://github.com/sapphrodite"> GitHub </a>
                <li> <a class = "modlink" rel="author" href=/pages/about.html> About </a>
            </ul>
        </nav>
    </header>
    <div id = "article-wrapper">
        <main id = "article-main">
            <article>
                <header class = "metadata">
                    <h1 class = "page-header">  Game Design with ECS  </h1>
                    <span class = "metadata-span">
                        Published on the 16th of November, 2020

                    </span>
                    <span class = "metadata-span">
                        Topics: <a class = "modlink" href = /archive/Game-Development.html> Game-Development</a>, <a class = "modlink" href = /archive/ECS.html> ECS</a>
                    </span>
                </header>
                <section>
                    
                    <p>
                        For the past several months I’ve been writing a game engine using the ECS framework, a data-oriented approach to game development that emphasizes composition and offers more flexibility than traditional object-oriented methods. ECS is an acronym for Entity, Component, and System, the three constituents of the architecture. Almost all functionality and objects within your game will be represented through a combination of these.
                    </p>
                    
                    <p>
                        First, the basics—ECS is a data-oriented architecture that utilizes composition and flexibility instead of object-oriented inheritance trees. The design philosophy is simple—Entities are game objects that are linked with Components, Components are structures of data that provide functionality to the entity they’re linked with, while Systems operate independently on Components to process the game’s data and logic. Objects in your world no longer have unique classes to represent them— entities are entirely compositional, with components being able to be added and removed at runtime - this allows for components to provide temporary modifiers e.g. a poison effect, for example. Entities are usually represented as a single integer ID, and methods of mapping entities components and systems together vary wildly—I’ll discuss different techniques and their rationales later on, but it’s important to remember that there’s no singular correct way to implement ECS.
                    </p>
                    
                    <span>
                        The design is simple:
                    </span>
                    
                    <ul>
                        
                        <li>
                            Entities are game objects, usually represented as integer IDs
                        </li>
                        
                        <li>
                            Components are data structures that provide data and state to the entity they link with
                        </li>
                        
                        <li>
                            Systems operate independently on Components to process the game’s data and logic.
                        </li>
                        
                    </ul>
                    
                    <p>
                        There are two main advantages to an ECS architecture - first, its data-oriented approach reduces code duplication and leads to simpler and more intuitive/maintainable code. Second, data-oriented architectures help optimization efforts in an era where multithreading and cache optimization are incredibly important. Let's go through the constituent parts one by one.
                    </p>
                    
                </section>
                <nav class = "toc">
                    <ol>
                        <li> <a class = "modlink" href = "#Entities">Entities</a> </li>
                        <li> <a class = "modlink" href = "#Components">Components</a> </li>
                        <li> <a class = "modlink" href = "#Systems">Systems</a> </li>
                        <li> <a class = "modlink" href = "#In_Conclusion">In Conclusion</a> </li>
                    </ol>
                </nav>
                <section id = "Entities">
                    <h2>Entities</h2>
                    
                    <p>
                        As mentioned, entities represent game objects and act as the “glue” of the engine. Entities are given data and characteristics by their components, and systems operate on this data to process game logic. Entities are usually linked to components by a container that stores which components an entity has and can be done in one of two ways – have component pools store which entities have their component, or have entities store which components they have. The second option is not preferable, as it requires each component type to have a numeric identifier, and it additionally centralizes all mapping data in one data structure which can lead to some very unfriendly code.
                    </p>
                    
                    <span>
                        A few implementation notes:
                    </span>
                    
                    <ul>
                        
                        <li>
                            Implementing entities as integer IDs greatly simplifies your code and allows for optimization both by the compiler and on an algorithmic level.
                        </li>
                        
                        <li>
                            With a maximum entity count, an entity manager can be as simple as a “free list” which keeps track of all the available entity IDs, and modify it based on entity creation/deletion
                        </li>
                        
                        <li>
                            It is possible to link entities to systems instead, but is generally avoided - this causes problems if one system needs to handle multiple component types.
                        </li>
                        
                        <li>
                            Bitmaps are the most space-efficient way of storing entity/component mapping, as you only need to store one bit per entry.
                        </li>
                        
                    </ul>
                    
                </section>
                <section id = "Components">
                    <h2>Components</h2>
                    
                    <p>
                        Components, plain and simple, are data buckets. As mentioned before, they provide characteristics and data to game objects, and can be added and removed at any time – poison effects are a great example of a temporary component. One thing to watch out for is bad component design, which can quickly lead to the spaghetti code you’re trying to avoid if you’re not careful - either do it the right way or don’t do it at all. Ask yourself - If the new functionality you want to add to a preexisting system is an essential aspect of it, why didn’t you add it in the first place? Oftentimes something two things that seem like they belong together are actually better off as separate - maximum granularity is key to making the most out of an ECS architecture.
                    </p>
                    
                    <span>
                        Some advice on how to store and operate on components:
                    </span>
                    
                    <ul>
                        
                        <li>
                            Pooling components in contiguous memory using a data structure that can access, add and delete components in constant time will allow for better speed, cache locality and promote system independence
                        </li>
                        
                        <li>
                            Components should ideally contain no game code besides, perhasps, convenience methods to modify their own state.
                        </li>
                        
                        <li>
                            If you want dynamic storage then a slot map is probably your best data structure. If you prefer static storage, arrays indexed by entity ID are a simpler cheaper.
                        </li>
                        
                        <li>
                            An aside for static storage users – To get the next element in a pool, it’s highly preferable to count trailing zeros on the bitmap, because looping eats up cycles testing empty slots.
                        </li>
                        
                    </ul>
                    
                </section>
                <section id = "Systems">
                    <h2>Systems</h2>
                    
                    <p>
                        Systems operate on entities and components to process the logic of the game – collision detection, an AI pathfinder and damage are all examples of distinct systems. Systems and their code exist independently of each other, leading to easier debugging, bugfixing, and reducing the chances of spaghetti code. The separation of game logic into discrete units makes it incredibly easy to implement multithreading - it can be as simple as running systems in different threads!
                    </p>
                    
                    <span>
                        Proper memory utilization is key to system performance:
                    </span>
                    
                    <ul>
                        
                        <li>
                            If multiple systems write to the same memory, either put them in the same thread or find a non-blocking alternative to mutexes – you only have 16ms of calculations per frame, don't burn it on mutex locks.
                        </li>
                        
                        <li>
                            Ensure systems operate on component pools rather than an entity list – iterating through list of all entities is inefficient, redundant, and scales poorly with higher entity counts. Additionally, focusing solely on relations between data is a cleaner solution.
                        </li>
                        
                    </ul>
                    
                </section>
                <section id = "In_Conclusion">
                    <h2>In Conclusion</h2>
                    
                    <p>
                        ECS is a very useful architecture for game design, providing both flexibility and the potential for lots of optimizations. It's worth mentioning again that like every new framework or architecture that comes around, receiving performance benefits from ECS is reliant on the quality of your implementation. I’ll likely cover specific optimization later, but this should be enough to get started.
                    </p>
                    
                </section>
            </article>
        </main>
        <nav id = "article-nav">
            <div class = "sidebar-sect">
    <span class = "navlist-label" id = "Articles-by-Quarter">Articles by Quarter</span>
    <ul aria-labelledby = "Articles-by-Quarter" class = "article-group-sidebar">
        <li>
            <input type = "checkbox" id = "Q4_2020">
            <label class = "label-toggle" for = "Q4_2020">Q4 2020 </label>
            <ul class = "menu-content">
                <li> <a href = "/articles/game_design_with_ECS.html" >  Game Design with ECS </a> </li>
            </ul>
        </li>
    </ul>
</div>
<div class = "sidebar-sect">
    <span class = "navlist-label" id = "Articles-by-Topic">Articles by Topic</span>
    <ul aria-labelledby = "Articles-by-Topic" class = "article-group-sidebar">
        <li>
            <input type = "checkbox" id = "Game-Development">
            <label class = "label-toggle" for = "Game-Development">Game-Development </label>
            <ul class = "menu-content">
                <li> <a href = "/articles/game_design_with_ECS.html" >  Game Design with ECS </a> </li>
            </ul>
        </li>
        <li>
            <input type = "checkbox" id = "ECS">
            <label class = "label-toggle" for = "ECS">ECS </label>
            <ul class = "menu-content">
                <li> <a href = "/articles/game_design_with_ECS.html" >  Game Design with ECS </a> </li>
            </ul>
        </li>
    </ul>
</div>

        </nav>
        <nav id = "footer-nav">
            <ul>
                <li id="prev-button">← Prev
                <li id="top-button"> <a class = "modlink"  href = "#site-header"> ↑ Top ↑ </a>
                <li id="next-button">Next →
            </ul>
        </nav>

    </div>
</body>
</html>
